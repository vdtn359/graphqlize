type Query {
  getInstrument(by: GetInstrumentInput!): Instrument
  listInstruments(filter: ListInstrumentsInput, pagination: Pagination = {limit: 20}, sort: [SortInstrument!]): Instruments!
  aggregateInstruments(filter: ListInstrumentsInput, groupBy: InstrumentsGroupBy, having: InstrumentsHaving): AggregateInstruments
  getOrchestra(by: GetOrchestraInput!): Orchestra
  listOrchestras(filter: ListOrchestrasInput, pagination: Pagination = {limit: 20}, sort: [SortOrchestra!]): Orchestras!
  aggregateOrchestras(filter: ListOrchestrasInput, groupBy: OrchestrasGroupBy, having: OrchestrasHaving): AggregateOrchestras
  getSession(by: GetSessionInput!): Session
  listSessions(filter: ListSessionsInput, pagination: Pagination = {limit: 20}, sort: [SortSession!]): Sessions!
  aggregateSessions(filter: ListSessionsInput, groupBy: SessionsGroupBy, having: SessionsHaving): AggregateSessions
  getStat(by: GetStatInput!): Stat
  listStats(filter: ListStatsInput, pagination: Pagination = {limit: 20}, sort: [SortStat!]): Stats!
  aggregateStats(filter: ListStatsInput, groupBy: StatsGroupBy, having: StatsHaving): AggregateStats
  getUserSession(by: GetUserSessionInput!): UserSession
  listUserSessions(filter: ListUserSessionsInput, pagination: Pagination = {limit: 20}, sort: [SortUserSession!]): UserSessions!
  aggregateUserSessions(filter: ListUserSessionsInput, groupBy: UserSessionsGroupBy, having: UserSessionsHaving): AggregateUserSessions
  getUser(by: GetUserInput!): User
  listUsers(filter: ListUsersInput, pagination: Pagination = {limit: 20}, sort: [SortUser!]): Users!
  aggregateUsers(filter: ListUsersInput, groupBy: UsersGroupBy, having: UsersHaving): AggregateUsers
}

type Instrument {
  userId: Int
  orchestraId: Int
  id: Int!
  type: String!
  description: String
  purchaseDate: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
  user: User
  orchestra: Orchestra
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

type User {
  statsId: Int
  mentorId: Int
  id: Int!
  username: String!
  provider: UsersProviderEnum!
  email: String!
  details: JSONObject
  verified: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
  stats: Stat
  mentor: User
  instruments(filter: ListInstrumentsInput, pagination: Pagination = {limit: 20}, sort: [SortInstrument!]): Instruments!
  userSessions(filter: ListUserSessionsInput, pagination: Pagination = {limit: 20}, sort: [SortUserSession!]): UserSessions!
  students(filter: ListUsersInput, pagination: Pagination = {limit: 20}, sort: [SortUser!]): Users!
}

enum UsersProviderEnum {
  google
  facebook
  local
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type Stat {
  id: Int!
  exp: Int!
  likes: Int!
  views: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  users(filter: ListUsersInput, pagination: Pagination = {limit: 20}, sort: [SortUser!]): Users!
  user: User
}

type Users {
  records: [User!]!
  limit: Int!
  offset: Int!
  count: Int
}

input ListUsersInput {
  _nested: Boolean
  _not: ListUsersInput
  _raw: RawExpression
  _and: [ListUsersInput!]
  _or: [ListUsersInput!]
  statsId: NumberFilter
  mentorId: NumberFilter
  id: NumberFilter
  username: StringFilter
  provider: UsersProviderEnumFilter
  email: StringFilter
  details: JsonFilter
  verified: BooleanFilter
  createdAt: DateFilter
  updatedAt: DateFilter
  stats: ListStatsInput
  mentor: ListUsersInput
  instruments: ListInstrumentsInput
  userSessions: ListUserSessionsInput
  students: ListUsersInput
}

input RawExpression {
  expression: String
  bindings: [JSON]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

input NumberFilter {
  _eq: Float
  _neq: Float
  _lt: Float
  _lte: Float
  _gt: Float
  _gte: Float
  _between: [Float]
  _notBetween: [Float]
  _in: [Float]
  _notIn: [Float]
}

input StringFilter {
  _eq: String
  _neq: String
  _lt: String
  _lte: String
  _gt: String
  _gte: String
  _like: String
  _iLike: String
  _regExp: String
  _iRegExp: String
  _between: [String!]
  _notBetween: [String!]
  _in: [String]
  _notIn: [String]
  _contains: String
  _startsWith: String
  _endsWith: String
}

input UsersProviderEnumFilter {
  _eq: UsersProviderEnum
  _neq: UsersProviderEnum
  _in: [UsersProviderEnum]
  _notIn: [UsersProviderEnum]
}

input JsonFilter {
  _fields: [JsonFieldFilter!]!
}

input JsonFieldFilter {
  field: String!
  value: StringNumberFilter!
}

input StringNumberFilter {
  _eq: StringNumber
  _neq: StringNumber
  _lt: StringNumber
  _lte: StringNumber
  _gt: StringNumber
  _gte: StringNumber
  _like: StringNumber
  _iLike: StringNumber
  _regExp: StringNumber
  _iRegExp: StringNumber
  _between: [StringNumber!]
  _notBetween: [StringNumber!]
  _in: [StringNumber]
  _notIn: [StringNumber]
  _contains: StringNumber
  _startsWith: StringNumber
  _endsWith: StringNumber
}

"""number or string"""
scalar StringNumber

input BooleanFilter {
  _eq: Boolean
  _neq: Boolean
}

input DateFilter {
  _eq: Date
  _neq: Date
  _lt: Date
  _lte: Date
  _gt: Date
  _gte: Date
  _between: [Date]
  _notBetween: [Date]
  _in: [Date]
  _notIn: [Date]
  _year: NumberFilter
  _month: NumberFilter
  _day: NumberFilter
  _hour: NumberFilter
  _minute: NumberFilter
  _second: NumberFilter
  _dayOfWeek: NumberFilter
  _date: StringFilter
}

scalar Date

input ListStatsInput {
  _nested: Boolean
  _not: ListStatsInput
  _raw: RawExpression
  _and: [ListStatsInput!]
  _or: [ListStatsInput!]
  id: NumberFilter
  exp: NumberFilter
  likes: NumberFilter
  views: NumberFilter
  createdAt: DateFilter
  updatedAt: DateFilter
  user: ListUsersInput
  users: ListUsersInput
}

input ListInstrumentsInput {
  _nested: Boolean
  _not: ListInstrumentsInput
  _raw: RawExpression
  _and: [ListInstrumentsInput!]
  _or: [ListInstrumentsInput!]
  userId: NumberFilter
  orchestraId: NumberFilter
  id: NumberFilter
  type: StringFilter
  description: StringFilter
  purchaseDate: DateFilter
  createdAt: DateFilter
  updatedAt: DateFilter
  user: ListUsersInput
  orchestra: ListOrchestrasInput
}

input ListOrchestrasInput {
  _nested: Boolean
  _not: ListOrchestrasInput
  _raw: RawExpression
  _and: [ListOrchestrasInput!]
  _or: [ListOrchestrasInput!]
  id: NumberFilter
  name: StringFilter
  createdAt: DateFilter
  updatedAt: DateFilter
  instruments: ListInstrumentsInput
}

input ListUserSessionsInput {
  _nested: Boolean
  _not: ListUserSessionsInput
  _raw: RawExpression
  _and: [ListUserSessionsInput!]
  _or: [ListUserSessionsInput!]
  userId: NumberFilter
  sessionId: NumberFilter
  id: NumberFilter
  time: DateFilter
  createdAt: DateFilter
  updatedAt: DateFilter
  user: ListUsersInput
  session: ListSessionsInput
}

input ListSessionsInput {
  _nested: Boolean
  _not: ListSessionsInput
  _raw: RawExpression
  _and: [ListSessionsInput!]
  _or: [ListSessionsInput!]
  id: NumberFilter
  name: StringFilter
  start: DateFilter
  end: DateFilter
  time: StringFilter
  location: StringFilter
  createdAt: DateFilter
  updatedAt: DateFilter
  userSessions: ListUserSessionsInput
}

input Pagination {
  disabled: Boolean
  page: Int
  limit: Int = 20
  offset: Int = 0
}

input SortUser {
  statsId: SortOption
  mentorId: SortOption
  id: SortOption
  username: SortOption
  provider: SortOption
  email: SortOption
  details: SortOption
  verified: SortOption
  createdAt: SortOption
  updatedAt: SortOption
  stats: SortStat
  mentor: SortUser
  instruments: SortInstrument
  userSessions: SortUserSession
  students: SortUser
}

input SortOption {
  direction: SortDirection!
  nulls: NullsDirection
}

enum SortDirection {
  ASC
  DESC
}

enum NullsDirection {
  FIRST
  LAST
}

input SortStat {
  id: SortOption
  exp: SortOption
  likes: SortOption
  views: SortOption
  createdAt: SortOption
  updatedAt: SortOption
  user: SortUser
  users: SortUser
}

input SortInstrument {
  userId: SortOption
  orchestraId: SortOption
  id: SortOption
  type: SortOption
  description: SortOption
  purchaseDate: SortOption
  createdAt: SortOption
  updatedAt: SortOption
  user: SortUser
  orchestra: SortOrchestra
}

input SortOrchestra {
  id: SortOption
  name: SortOption
  createdAt: SortOption
  updatedAt: SortOption
  instruments: SortInstrument
}

input SortUserSession {
  userId: SortOption
  sessionId: SortOption
  id: SortOption
  time: SortOption
  createdAt: SortOption
  updatedAt: SortOption
  user: SortUser
  session: SortSession
}

input SortSession {
  id: SortOption
  name: SortOption
  start: SortOption
  end: SortOption
  time: SortOption
  location: SortOption
  createdAt: SortOption
  updatedAt: SortOption
  userSessions: SortUserSession
}

type Instruments {
  records: [Instrument!]!
  limit: Int!
  offset: Int!
  count: Int
}

type UserSessions {
  records: [UserSession!]!
  limit: Int!
  offset: Int!
  count: Int
}

type UserSession {
  userId: Int
  sessionId: Int
  id: Int!
  time: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
  user: User
  session: Session
}

type Session {
  id: Int!
  name: String!
  start: DateTime!
  end: DateTime!
  time: String!
  location: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  userSessions(filter: ListUserSessionsInput, pagination: Pagination = {limit: 20}, sort: [SortUserSession!]): UserSessions!
}

type Orchestra {
  id: Int!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  instruments(filter: ListInstrumentsInput, pagination: Pagination = {limit: 20}, sort: [SortInstrument!]): Instruments!
}

input GetInstrumentInput {
  id: Int
}

type AggregateInstruments {
  group: JSON
  count: CountInstruments
  avg: AvgInstruments
  sum: SumInstruments
  min: MinInstruments
  max: MaxInstruments
}

type CountInstruments {
  userId: Int
  orchestraId: Int
  id: Int
  type: Int
  description: Int
  purchaseDate: Int
  createdAt: Int
  updatedAt: Int
}

type AvgInstruments {
  userId: Float
  orchestraId: Float
  id: Float
}

type SumInstruments {
  userId: Int
  orchestraId: Int
  id: Int
}

type MinInstruments {
  userId: Int
  orchestraId: Int
  id: Int
}

type MaxInstruments {
  userId: Int
  orchestraId: Int
  id: Int
}

input InstrumentsGroupBy {
  userId: Boolean
  orchestraId: Boolean
  id: Boolean
  type: Boolean
  description: Boolean
  purchaseDate: Boolean
  createdAt: Boolean
  updatedAt: Boolean
}

""""""
input InstrumentsHaving {
  _nested: Boolean
  _not: ListInstrumentsInput
  _raw: RawExpression
  _and: [ListInstrumentsInput!]
  _or: [ListInstrumentsInput!]
  userId: NumberFilter
  orchestraId: NumberFilter
  id: NumberFilter
  type: StringFilter
  description: StringFilter
  purchaseDate: DateFilter
  createdAt: DateFilter
  updatedAt: DateFilter
  user: ListUsersInput
  orchestra: ListOrchestrasInput
}

input GetOrchestraInput {
  id: Int
}

type Orchestras {
  records: [Orchestra!]!
  limit: Int!
  offset: Int!
  count: Int
}

type AggregateOrchestras {
  group: JSON
  count: CountOrchestras
  avg: AvgOrchestras
  sum: SumOrchestras
  min: MinOrchestras
  max: MaxOrchestras
}

type CountOrchestras {
  id: Int
  name: Int
  createdAt: Int
  updatedAt: Int
}

type AvgOrchestras {
  id: Float
}

type SumOrchestras {
  id: Int
}

type MinOrchestras {
  id: Int
}

type MaxOrchestras {
  id: Int
}

input OrchestrasGroupBy {
  id: Boolean
  name: Boolean
  createdAt: Boolean
  updatedAt: Boolean
}

""""""
input OrchestrasHaving {
  _nested: Boolean
  _not: ListOrchestrasInput
  _raw: RawExpression
  _and: [ListOrchestrasInput!]
  _or: [ListOrchestrasInput!]
  id: NumberFilter
  name: StringFilter
  createdAt: DateFilter
  updatedAt: DateFilter
  instruments: ListInstrumentsInput
}

input GetSessionInput {
  id: Int
}

type Sessions {
  records: [Session!]!
  limit: Int!
  offset: Int!
  count: Int
}

type AggregateSessions {
  group: JSON
  count: CountSessions
  avg: AvgSessions
  sum: SumSessions
  min: MinSessions
  max: MaxSessions
}

type CountSessions {
  id: Int
  name: Int
  start: Int
  end: Int
  time: Int
  location: Int
  createdAt: Int
  updatedAt: Int
}

type AvgSessions {
  id: Float
}

type SumSessions {
  id: Int
}

type MinSessions {
  id: Int
}

type MaxSessions {
  id: Int
}

input SessionsGroupBy {
  id: Boolean
  name: Boolean
  start: Boolean
  end: Boolean
  time: Boolean
  location: Boolean
  createdAt: Boolean
  updatedAt: Boolean
}

""""""
input SessionsHaving {
  _nested: Boolean
  _not: ListSessionsInput
  _raw: RawExpression
  _and: [ListSessionsInput!]
  _or: [ListSessionsInput!]
  id: NumberFilter
  name: StringFilter
  start: DateFilter
  end: DateFilter
  time: StringFilter
  location: StringFilter
  createdAt: DateFilter
  updatedAt: DateFilter
  userSessions: ListUserSessionsInput
}

input GetStatInput {
  id: Int
}

type Stats {
  records: [Stat!]!
  limit: Int!
  offset: Int!
  count: Int
}

type AggregateStats {
  group: JSON
  count: CountStats
  avg: AvgStats
  sum: SumStats
  min: MinStats
  max: MaxStats
}

type CountStats {
  id: Int
  exp: Int
  likes: Int
  views: Int
  createdAt: Int
  updatedAt: Int
}

type AvgStats {
  id: Float
  exp: Float
  likes: Float
  views: Float
}

type SumStats {
  id: Int
  exp: Int
  likes: Int
  views: Int
}

type MinStats {
  id: Int
  exp: Int
  likes: Int
  views: Int
}

type MaxStats {
  id: Int
  exp: Int
  likes: Int
  views: Int
}

input StatsGroupBy {
  id: Boolean
  exp: Boolean
  likes: Boolean
  views: Boolean
  createdAt: Boolean
  updatedAt: Boolean
}

""""""
input StatsHaving {
  _nested: Boolean
  _not: ListStatsInput
  _raw: RawExpression
  _and: [ListStatsInput!]
  _or: [ListStatsInput!]
  id: NumberFilter
  exp: NumberFilter
  likes: NumberFilter
  views: NumberFilter
  createdAt: DateFilter
  updatedAt: DateFilter
  user: ListUsersInput
  users: ListUsersInput
}

input GetUserSessionInput {
  id: Int
}

type AggregateUserSessions {
  group: JSON
  count: CountUserSessions
  avg: AvgUserSessions
  sum: SumUserSessions
  min: MinUserSessions
  max: MaxUserSessions
}

type CountUserSessions {
  userId: Int
  sessionId: Int
  id: Int
  time: Int
  createdAt: Int
  updatedAt: Int
}

type AvgUserSessions {
  userId: Float
  sessionId: Float
  id: Float
}

type SumUserSessions {
  userId: Int
  sessionId: Int
  id: Int
}

type MinUserSessions {
  userId: Int
  sessionId: Int
  id: Int
}

type MaxUserSessions {
  userId: Int
  sessionId: Int
  id: Int
}

input UserSessionsGroupBy {
  userId: Boolean
  sessionId: Boolean
  id: Boolean
  time: Boolean
  createdAt: Boolean
  updatedAt: Boolean
}

""""""
input UserSessionsHaving {
  _nested: Boolean
  _not: ListUserSessionsInput
  _raw: RawExpression
  _and: [ListUserSessionsInput!]
  _or: [ListUserSessionsInput!]
  userId: NumberFilter
  sessionId: NumberFilter
  id: NumberFilter
  time: DateFilter
  createdAt: DateFilter
  updatedAt: DateFilter
  user: ListUsersInput
  session: ListSessionsInput
}

input GetUserInput {
  id: Int
  statsId: Int
  username: String
  email__provider: UsersEmailProviderKey
}

input UsersEmailProviderKey {
  email: String!
  provider: EnumValues!
}

enum EnumValues {
  google
  facebook
  local
}

type AggregateUsers {
  group: JSON
  count: CountUsers
  avg: AvgUsers
  sum: SumUsers
  min: MinUsers
  max: MaxUsers
}

type CountUsers {
  statsId: Int
  mentorId: Int
  id: Int
  username: Int
  provider: Int
  email: Int
  details: Int
  verified: Int
  createdAt: Int
  updatedAt: Int
}

type AvgUsers {
  statsId: Float
  mentorId: Float
  id: Float
}

type SumUsers {
  statsId: Int
  mentorId: Int
  id: Int
}

type MinUsers {
  statsId: Int
  mentorId: Int
  id: Int
}

type MaxUsers {
  statsId: Int
  mentorId: Int
  id: Int
}

input UsersGroupBy {
  statsId: Boolean
  mentorId: Boolean
  id: Boolean
  username: Boolean
  provider: Boolean
  email: Boolean
  details: Boolean
  verified: Boolean
  createdAt: Boolean
  updatedAt: Boolean
}

""""""
input UsersHaving {
  _nested: Boolean
  _not: ListUsersInput
  _raw: RawExpression
  _and: [ListUsersInput!]
  _or: [ListUsersInput!]
  statsId: NumberFilter
  mentorId: NumberFilter
  id: NumberFilter
  username: StringFilter
  provider: UsersProviderEnumFilter
  email: StringFilter
  details: JsonFilter
  verified: BooleanFilter
  createdAt: DateFilter
  updatedAt: DateFilter
  stats: ListStatsInput
  mentor: ListUsersInput
  instruments: ListInstrumentsInput
  userSessions: ListUserSessionsInput
  students: ListUsersInput
}